# name: test/sql/pac_multi_pu.test
# description: Tests for PAC multi-privacy-unit behavior with varied PK/FK combinations
# group: [sql]

require pac

statement ok
PRAGMA clear_pac_metadata;

statement ok
SET pac_seed = 42

statement ok
SET pac_deterministic_noise = true

statement ok
SET threads = 1

statement ok
SET pac_mi = 0

# Setup: create tables with various PK/FK configurations
statement ok
CREATE TABLE pu_a (id INTEGER PRIMARY KEY, grp INTEGER, val INTEGER);

statement ok
CREATE TABLE pu_b (id INTEGER PRIMARY KEY, gid INTEGER, val_b INTEGER);

# composite PK table (two-column primary key)
statement ok
CREATE TABLE pu_c (a_id INTEGER, b_id INTEGER, val_c INTEGER, PRIMARY KEY(a_id, b_id));

# table with no declared PK (rowid will be used)
statement ok
CREATE TABLE pu_no_pk (grp INTEGER, val INTEGER);

# intermediate tables linking to privacy units via FKs
statement ok
CREATE TABLE mid_ab (
    mid_id INTEGER PRIMARY KEY,
    a_fk INTEGER,
    b_fk INTEGER,
    data_val INTEGER,
    FOREIGN KEY (a_fk) REFERENCES pu_a(id),
    FOREIGN KEY (b_fk) REFERENCES pu_b(id)
);

statement ok
CREATE TABLE mid_ac (
    mid_id INTEGER PRIMARY KEY,
    a_fk INTEGER,
    c_fk_a INTEGER,
    c_fk_b INTEGER,
    data_val INTEGER,
    FOREIGN KEY (a_fk) REFERENCES pu_a(id),
    FOREIGN KEY (c_fk_a, c_fk_b) REFERENCES pu_c(a_id, b_id)
);

# Non-PU table that joins with pu_no_pk (cannot use FK to table without PK)
statement ok
CREATE TABLE mid_no_pk (
    mid_id INTEGER PRIMARY KEY,
    grp INTEGER,
    data_val INTEGER
);

# populate data
statement ok
INSERT INTO pu_a SELECT i, i % 3, i % 10 FROM range(30) t(i);

statement ok
INSERT INTO pu_b SELECT i, i % 4, (i * 2) % 7 FROM range(30) t(i);

statement ok
INSERT INTO pu_c SELECT i % 5, i % 6, (i * 3) % 11 FROM range(30) t(i);

statement ok
INSERT INTO pu_no_pk SELECT i % 5, i % 13 FROM range(30) t(i);

statement ok
INSERT INTO mid_ab SELECT i, i % 10, i % 11, i * 2 FROM range(30) t(i);

statement ok
INSERT INTO mid_ac SELECT i, i % 10, i % 5, i % 6, i * 3 FROM range(30) t(i);

statement ok
INSERT INTO mid_no_pk SELECT i, i % 5, i * 4 FROM range(30) t(i);

# Add PAC privacy units for pu_a and pu_b and pu_c and pu_no_pk
statement ok
ALTER TABLE pu_a SET PU;

statement ok
ALTER TABLE pu_b SET PU;

statement ok
ALTER TABLE pu_c SET PU;

statement ok
ALTER TABLE pu_no_pk SET PU;

# Basic aggregate on intermediate table joining single PU
query I
SELECT SUM(m.data_val) FROM mid_ab m JOIN pu_a a ON m.a_fk = a.id
----
1104

# Aggregate with JOIN between two PUs via intermediate table
query I
SELECT SUM(m.data_val)
FROM mid_ab m JOIN pu_a a ON m.a_fk = a.id JOIN pu_b b ON m.b_fk = b.id
----
1460

# Multi-PU join: joining through mid_ac to both pu_a and pu_c
query I
SELECT SUM(m.data_val)
FROM mid_ac m JOIN pu_a a ON m.a_fk = a.id JOIN pu_c c ON m.c_fk_a = c.a_id AND m.c_fk_b = c.b_id
----
1872

# Test with table without PK (pu_no_pk) - join via non-FK column match
query I
SELECT SUM(m.data_val)
FROM mid_no_pk m JOIN pu_no_pk np ON m.grp = np.grp
----
11232

# Multi-PU with GROUP BY on non-PU column (use mid_id which is not a join key)
query II
SELECT m.mid_id, SUM(m.data_val)
FROM mid_ab m JOIN pu_a a ON m.a_fk = a.id JOIN pu_b b ON m.b_fk = b.id
GROUP BY m.mid_id
ORDER BY m.mid_id
LIMIT 3
----
0	0
1	4
2	8

# Three-way multi-PU join
query I
SELECT SUM(m1.data_val + m2.data_val)
FROM mid_ab m1
JOIN pu_a a ON m1.a_fk = a.id
JOIN pu_b b ON m1.b_fk = b.id
JOIN mid_ac m2 ON m1.a_fk = m2.a_fk
JOIN pu_c c ON m2.c_fk_a = c.a_id AND m2.c_fk_b = c.b_id
----
11310

# Test join elimination path: when configured, avoid joining PU table but use FK columns
statement ok
SET pac_join_elimination = true;

query I
SELECT SUM(m.data_val)
FROM mid_ab m JOIN pu_a a ON m.a_fk = a.id
----
1104

statement ok
SET pac_join_elimination = false;

# Test COUNT with multi-PU
query I
SELECT COUNT(*)
FROM mid_ab m JOIN pu_a a ON m.a_fk = a.id JOIN pu_b b ON m.b_fk = b.id
----
50

# Test AVG with multi-PU
query I
SELECT AVG(m.data_val)::DECIMAL(5,2)
FROM mid_ab m JOIN pu_a a ON m.a_fk = a.id JOIN pu_b b ON m.b_fk = b.id
----
48.67

# STRESS TEST: Complex multi-PU scenario with all PU types
# This query joins ALL privacy units (pu_a, pu_b, pu_c, pu_no_pk) in a single query
# with multiple aggregates - no self-joins
statement ok
CREATE TABLE mid_all (
    mid_id INTEGER PRIMARY KEY,
    a_fk INTEGER,
    b_fk INTEGER,
    c_fk_a INTEGER,
    c_fk_b INTEGER,
    np_grp INTEGER,
    data_val INTEGER,
    FOREIGN KEY (a_fk) REFERENCES pu_a(id),
    FOREIGN KEY (b_fk) REFERENCES pu_b(id),
    FOREIGN KEY (c_fk_a, c_fk_b) REFERENCES pu_c(a_id, b_id)
);

statement ok
INSERT INTO mid_all SELECT i, i % 10, i % 11, i % 5, i % 6, i % 5, i * 5 FROM range(30) t(i);

# Four-way PU join: pu_a (single PK), pu_b (single PK), pu_c (composite PK), pu_no_pk (no PK/rowid)
# This is the ultimate stress test - all PU types in one query
query III
SELECT
    COUNT(*) as cnt,
    SUM(m.data_val) as sum_val,
    AVG(m.data_val)::DECIMAL(5,2) as avg_val
FROM mid_all m
JOIN pu_a a ON m.a_fk = a.id
JOIN pu_b b ON m.b_fk = b.id
JOIN pu_c c ON m.c_fk_a = c.a_id AND m.c_fk_b = c.b_id
JOIN pu_no_pk np ON m.np_grp = np.grp
----
346	25520	141.78

# Multi-PU with MIN/MAX aggregates and GROUP BY on non-join-key
# Note: Grouping by mid_id creates single-row groups, PAC returns NULL for privacy
query IIII
SELECT
    m.mid_id,
    MIN(m.data_val) as min_val,
    MAX(m.data_val) as max_val,
    COUNT(*) as cnt
FROM mid_all m
JOIN pu_a a ON m.a_fk = a.id
JOIN pu_b b ON m.b_fk = b.id
GROUP BY m.mid_id
ORDER BY m.mid_id
LIMIT 1
----
0	0	0	2

# Test with multiple aggregates on same column but different PU combinations
query III
SELECT
    SUM(m.data_val) as sum_ab,
    COUNT(*) as cnt_abc,
    AVG(m.data_val)::DECIMAL(5,2) as avg_all
FROM mid_all m
JOIN pu_a a ON m.a_fk = a.id
JOIN pu_b b ON m.b_fk = b.id
JOIN pu_c c ON m.c_fk_a = c.a_id AND m.c_fk_b = c.b_id
----
4010	54	133.67

# Test with join elimination on multi-PU query
statement ok
SET pac_join_elimination = true;

query I
SELECT SUM(m.data_val)
FROM mid_all m
JOIN pu_a a ON m.a_fk = a.id
JOIN pu_b b ON m.b_fk = b.id
JOIN pu_c c ON m.c_fk_a = c.a_id AND m.c_fk_b = c.b_id
----
4010

statement ok
SET pac_join_elimination = false;

# Cleanup stress test tables

statement ok
DROP TABLE mid_all;

# Cleanup
statement ok
DROP TABLE mid_no_pk;

statement ok
DROP TABLE mid_ac;

statement ok
DROP TABLE mid_ab;

statement ok
DROP TABLE pu_no_pk;

statement ok
DROP TABLE pu_c;

statement ok
DROP TABLE pu_b;

statement ok
DROP TABLE pu_a;
