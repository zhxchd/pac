# name: test/sql/pac_parser.test
# description: Test PAC parser extension for CREATE PU TABLE and ALTER TABLE with PAC metadata
# group: [sql]

require pac

statement ok
PRAGMA clear_pac_metadata;

statement ok
SET pac_seed = 42

statement ok
SET pac_mi = 0

statement ok
SET pac_deterministic_noise = true

statement ok
SET threads = 1

# ============================================================================
# PAC Parser Tests: Basic Functionality
# ============================================================================

# Test 1: Simple CREATE PU TABLE with PAC_KEY
statement ok
CREATE PU TABLE users (
    user_id INTEGER,
    name VARCHAR,
    email VARCHAR,
    PAC_KEY (user_id)
);

# Verify table was created
query I
SELECT COUNT(*) FROM users;
----
NULL

# Test 2: CREATE TABLE (non-PU) with PAC_LINK to PU table
# Regular tables CAN link to PU tables - this is allowed
statement ok
CREATE TABLE orders (
    order_id INTEGER,
    user_id INTEGER,
    amount DECIMAL(10,2),
    PAC_LINK (user_id) REFERENCES users(user_id)
);

query I
SELECT COUNT(*) FROM orders;
----
NULL

# Test 3: CREATE PU TABLE with PROTECTED columns
statement ok
CREATE PU TABLE transactions (
    transaction_id INTEGER,
    order_id INTEGER,
    card_number VARCHAR,
    PROTECTED (card_number),
    PAC_KEY (transaction_id),
    PAC_LINK (order_id) REFERENCES orders(order_id)
);

query I
SELECT COUNT(*) FROM transactions;
----
NULL

# Note: transactions table has PROTECTED columns, so PAC compilation returns NULL for empty table

# Test 4: CREATE PU TABLE with multiple PAC clauses
statement ok
CREATE PU TABLE employees (
    emp_id INTEGER,
    dept_id INTEGER,
    salary INTEGER,
    ssn VARCHAR,
    PAC_KEY (emp_id),
    PAC_LINK (dept_id) REFERENCES departments(dept_id),
    PROTECTED (salary, ssn)
);

query I
SELECT COUNT(*) FROM employees;
----
NULL

# Note: employees table has PROTECTED columns, so PAC compilation returns NULL for empty table

# Test 5: Regular CREATE TABLE (no PAC keywords) should still work
statement ok
CREATE TABLE departments (
    dept_id INTEGER PRIMARY KEY,
    dept_name VARCHAR
);

query I
SELECT COUNT(*) FROM departments;
----
0

# Test 6: ALTER PU TABLE with PAC_KEY
statement ok
CREATE TABLE products (
    product_id INTEGER,
    name VARCHAR,
    price DECIMAL(10,2)
);

statement ok
ALTER PU TABLE products ADD PAC_KEY (product_id);

# Test 7: ALTER PU TABLE with PAC_LINK
statement ok
CREATE TABLE reviews (
    review_id INTEGER,
    product_id INTEGER,
    rating INTEGER
);

statement ok
ALTER PU TABLE reviews ADD PAC_LINK (product_id) REFERENCES products(product_id);

# Test 8: ALTER PU TABLE with PROTECTED columns
statement ok
ALTER PU TABLE reviews ADD PROTECTED (rating);

# Test 9: Save and load PAC metadata
statement ok
PRAGMA save_pac_metadata('__TEST_DIR__/pac_metadata_test.json');

statement ok
PRAGMA clear_pac_metadata;

statement ok
PRAGMA load_pac_metadata ('__TEST_DIR__/pac_metadata_test.json');

# Test 10: CREATE PU TABLE with IF NOT EXISTS
statement ok
CREATE PU TABLE IF NOT EXISTS customers (
    customer_id INTEGER,
    email VARCHAR,
    PAC_KEY (customer_id),
    PROTECTED (email)
);

query I
SELECT COUNT(*) FROM customers;
----
NULL

# Note: customers table has PROTECTED columns, so PAC compilation returns NULL for empty table

# Test 11: Multiple PAC_LINKs in one table
statement ok
CREATE TABLE order_items (
    item_id INTEGER,
    order_id INTEGER,
    product_id INTEGER,
    quantity INTEGER,
    PAC_LINK (order_id) REFERENCES orders(order_id),
    PAC_LINK (product_id) REFERENCES products(product_id)
);

query I
SELECT COUNT(*) FROM order_items;
----
NULL

# Test 12: Composite PAC_KEY
statement ok
CREATE PU TABLE inventory (
    warehouse_id INTEGER,
    product_id INTEGER,
    quantity INTEGER,
    PAC_KEY (warehouse_id, product_id)
);

query I
SELECT COUNT(*) FROM inventory;
----
NULL

# Cleanup
statement ok
DROP TABLE IF EXISTS users;

statement ok
DROP TABLE IF EXISTS orders;

statement ok
DROP TABLE IF EXISTS transactions;

statement ok
DROP TABLE IF EXISTS employees;

statement ok
DROP TABLE IF EXISTS departments;

statement ok
DROP TABLE IF EXISTS products;

statement ok
DROP TABLE IF EXISTS reviews;

statement ok
DROP TABLE IF EXISTS customers;

statement ok
DROP TABLE IF EXISTS order_items;

statement ok
DROP TABLE IF EXISTS inventory;

statement ok
PRAGMA clear_pac_metadata;

# ============================================================================
# Edge Case Tests: Validation and Error Handling
# ============================================================================

# Test 13: ALTER PU TABLE on non-existent table should fail
statement ok
CREATE TABLE test_table (id INTEGER, name VARCHAR);

statement error
ALTER PU TABLE nonexistent_table ADD PAC_LINK (id) REFERENCES test_table(id);
----
Table 'nonexistent_table' does not exist

# Test 14: ALTER PU TABLE with non-existent column should fail
statement error
ALTER PU TABLE test_table ADD PROTECTED (nonexistent_column);
----
Column 'nonexistent_column' does not exist in table 'test_table'

# Test 15: ALTER PU TABLE with PAC_LINK to non-existent local column should fail
statement error
ALTER PU TABLE test_table ADD PAC_LINK (nonexistent_col) REFERENCES test_table(id);
----
Column 'nonexistent_col' does not exist in table 'test_table'

# Test 16: ALTER PU TABLE with PAC_LINK to non-existent referenced table should fail
statement error
ALTER PU TABLE test_table ADD PAC_LINK (id) REFERENCES nonexistent_ref_table(id);
----
Referenced table 'nonexistent_ref_table' does not exist

# Test 17: ALTER PU TABLE with PAC_LINK to non-existent referenced column should fail
statement ok
CREATE TABLE ref_table (ref_id INTEGER, value VARCHAR);

statement error
ALTER PU TABLE test_table ADD PAC_LINK (id) REFERENCES ref_table(nonexistent_ref_col);
----
Column 'nonexistent_ref_col' does not exist in referenced table 'ref_table'

# Test 18: Multiple non-existent protected columns should fail
statement error
ALTER PU TABLE test_table ADD PROTECTED (col1, col2, col3);
----
Columns 'col1', 'col2', 'col3' do not exist in table 'test_table'. No protected columns were added.

# Test 19: Mix of existing and non-existing protected columns should fail atomically
statement error
ALTER PU TABLE test_table ADD PROTECTED (name, nonexistent_col);
----
Column 'nonexistent_col' does not exist in table 'test_table'

# Test 20: Composite PAC_LINK with non-existent local column should fail
statement ok
CREATE TABLE composite_test (id1 INTEGER, id2 INTEGER, data VARCHAR);

statement ok
CREATE TABLE composite_ref (ref1 INTEGER, ref2 INTEGER);

statement error
ALTER PU TABLE composite_test ADD PAC_LINK (id1, nonexistent_id) REFERENCES composite_ref(ref1, ref2);
----
Column 'nonexistent_id' does not exist in table 'composite_test'

# Test 21: Composite PAC_LINK with non-existent referenced column should fail
statement error
ALTER PU TABLE composite_test ADD PAC_LINK (id1, id2) REFERENCES composite_ref(ref1, nonexistent_ref);
----
Column 'nonexistent_ref' does not exist in referenced table 'composite_ref'

# Test 22: Valid ALTER PU TABLE operations should succeed
statement ok
ALTER PU TABLE test_table ADD PROTECTED (name);

statement ok
ALTER PU TABLE test_table ADD PAC_LINK (id) REFERENCES ref_table(ref_id);

# Test 23: Adding duplicate protected column should fail
statement error
ALTER PU TABLE test_table ADD PROTECTED (name);
----
Column 'name' is already marked as protected

# Test 24: Adding duplicate PAC_LINK should be idempotent (no error)
statement ok
ALTER PU TABLE test_table ADD PAC_LINK (id) REFERENCES ref_table(ref_id);

# Test 25: Case insensitivity - duplicate protected columns should fail
statement error
ALTER PU TABLE test_table ADD PROTECTED (NAME);
----
Column 'name' is already marked as protected

# Test 26: Case insensitivity - table and column names in PAC_LINK
statement ok
ALTER PU TABLE TEST_TABLE ADD PAC_LINK (ID) REFERENCES REF_TABLE(REF_ID);

# Test 27: Valid composite PAC_LINK should succeed
statement ok
ALTER PU TABLE composite_test ADD PAC_LINK (id1, id2) REFERENCES composite_ref(ref1, ref2);

# Test 28: Whitespace handling in column lists
statement ok
CREATE TABLE whitespace_test (col_a INTEGER, col_b INTEGER, col_c VARCHAR);

statement ok
ALTER PU TABLE whitespace_test ADD PROTECTED ( col_a , col_b , col_c );

statement ok
CREATE TABLE whitespace_ref (ref_a INTEGER, ref_b INTEGER);

statement ok
ALTER PU TABLE whitespace_test ADD PAC_LINK ( col_a , col_b ) REFERENCES whitespace_ref ( ref_a , ref_b );

# Test 29: Empty or malformed syntax should fail gracefully
# (These will fail at the SQL parser level before reaching PAC parser)

# Test 30: Multiple ALTER operations on same table accumulate metadata
statement ok
CREATE TABLE accumulate_test (id INTEGER, col1 VARCHAR, col2 VARCHAR, col3 INTEGER, ref_id INTEGER);

statement ok
ALTER PU TABLE accumulate_test ADD PROTECTED (col1);

statement ok
ALTER PU TABLE accumulate_test ADD PROTECTED (col2);

statement ok
ALTER PU TABLE accumulate_test ADD PAC_LINK (ref_id) REFERENCES ref_table(ref_id);

statement ok
ALTER PU TABLE accumulate_test ADD PROTECTED (col3);

# Test 31: Verify metadata persistence and reload
statement ok
PRAGMA save_pac_metadata('__TEST_DIR__/pac_edge_case_test.json');

statement ok
PRAGMA clear_pac_metadata;

statement ok
PRAGMA load_pac_metadata('__TEST_DIR__/pac_edge_case_test.json');

# Cleanup edge case tests
statement ok
DROP TABLE IF EXISTS test_table;

statement ok
DROP TABLE IF EXISTS ref_table;

statement ok
DROP TABLE IF EXISTS composite_test;

statement ok
DROP TABLE IF EXISTS composite_ref;

statement ok
DROP TABLE IF EXISTS whitespace_test;

statement ok
DROP TABLE IF EXISTS whitespace_ref;

statement ok
DROP TABLE IF EXISTS accumulate_test;

statement ok
PRAGMA clear_pac_metadata;

# ============================================================================
# Edge Case Tests: Duplicate Link and Protected Column Prevention
# ============================================================================

# Test 32: Duplicate PAC_LINK on same columns to different target should fail
statement ok
CREATE TABLE link_test (id INTEGER, ref_id INTEGER, data VARCHAR);

statement ok
CREATE TABLE target_a (id INTEGER);

statement ok
CREATE TABLE target_b (id INTEGER);

statement ok
ALTER PU TABLE link_test ADD PAC_LINK (ref_id) REFERENCES target_a(id);

statement error
ALTER PU TABLE link_test ADD PAC_LINK (ref_id) REFERENCES target_b(id);
----
Column(s) already have a PAC_LINK defined

# Test 33: Same PAC_LINK twice should be idempotent (no error)
statement ok
ALTER PU TABLE link_test ADD PAC_LINK (ref_id) REFERENCES target_a(id);

# Test 34: Composite key duplicate link to different target should fail
statement ok
CREATE TABLE comp_link_test (id1 INTEGER, id2 INTEGER, data VARCHAR);

statement ok
CREATE TABLE comp_target_a (key1 INTEGER, key2 INTEGER);

statement ok
CREATE TABLE comp_target_b (key1 INTEGER, key2 INTEGER);

statement ok
ALTER PU TABLE comp_link_test ADD PAC_LINK (id1, id2) REFERENCES comp_target_a(key1, key2);

statement error
ALTER PU TABLE comp_link_test ADD PAC_LINK (id1, id2) REFERENCES comp_target_b(key1, key2);
----
Column(s) already have a PAC_LINK defined

# Cleanup duplicate tests
statement ok
DROP TABLE IF EXISTS link_test;

statement ok
DROP TABLE IF EXISTS target_a;

statement ok
DROP TABLE IF EXISTS target_b;

statement ok
DROP TABLE IF EXISTS comp_link_test;

statement ok
DROP TABLE IF EXISTS comp_target_a;

statement ok
DROP TABLE IF EXISTS comp_target_b;

statement ok
PRAGMA clear_pac_metadata;

# ============================================================================
# DROP PAC Constraint Tests
# ============================================================================

# Test 35: Setup tables for DROP tests
statement ok
CREATE PU TABLE drop_test (
    id INTEGER,
    col1 VARCHAR,
    col2 VARCHAR,
    col3 INTEGER,
    ref_id INTEGER,
    PAC_KEY (id),
    PROTECTED (col1, col2)
);

statement ok
CREATE TABLE drop_ref_table (ref_id INTEGER);

statement ok
ALTER PU TABLE drop_test ADD PAC_LINK (ref_id) REFERENCES drop_ref_table(ref_id);

# Test 36: DROP PROTECTED column
statement ok
ALTER PU TABLE drop_test DROP PROTECTED (col1);

# Verify col1 is no longer protected (add it again should work)
statement ok
ALTER PU TABLE drop_test ADD PROTECTED (col1);

# Test 37: DROP multiple PROTECTED columns
statement ok
ALTER PU TABLE drop_test DROP PROTECTED (col1, col2);

# Test 38: DROP PROTECTED column that doesn't exist should fail
statement error
ALTER PU TABLE drop_test DROP PROTECTED (nonexistent_col);
----
Column 'nonexistent_col' is not marked as protected

# Test 39: DROP PROTECTED column that's not protected should fail
statement error
ALTER PU TABLE drop_test DROP PROTECTED (col3);
----
Column 'col3' is not marked as protected

# Test 40: DROP PAC_LINK
statement ok
ALTER PU TABLE drop_test DROP PAC_LINK (ref_id);

# Verify link is removed (add it again should work)
statement ok
ALTER PU TABLE drop_test ADD PAC_LINK (ref_id) REFERENCES drop_ref_table(ref_id);

# Test 41: DROP PAC_LINK that doesn't exist should fail
statement error
ALTER PU TABLE drop_test DROP PAC_LINK (col3);
----
No PAC LINK found on column 'col3'

# Test 42: DROP PAC_LINK with composite key
statement ok
CREATE TABLE comp_drop_test (id1 INTEGER, id2 INTEGER, data VARCHAR);

statement ok
CREATE TABLE comp_drop_ref (ref1 INTEGER, ref2 INTEGER);

statement ok
ALTER PU TABLE comp_drop_test ADD PAC_LINK (id1, id2) REFERENCES comp_drop_ref(ref1, ref2);

statement ok
ALTER PU TABLE comp_drop_test DROP PAC_LINK (id1, id2);

# Test 43: DROP composite PAC_LINK that doesn't exist should fail
statement error
ALTER PU TABLE comp_drop_test DROP PAC_LINK (id1, id2);
----
No PAC LINK found on columns ('id1', 'id2')

# Test 44: DROP from table without PAC metadata should fail
statement ok
CREATE TABLE no_pac_table (id INTEGER, name VARCHAR);

statement error
ALTER PU TABLE no_pac_table DROP PROTECTED (name);
----
Table 'no_pac_table' does not have any PAC metadata to drop

# Test 45: Case insensitivity in DROP operations
statement ok
ALTER PU TABLE drop_test ADD PROTECTED (col1);

statement ok
ALTER PU TABLE drop_test DROP PROTECTED (COL1);

# Test 46: DROP TABLE with PAC metadata should clean up metadata
statement ok
CREATE PU TABLE cleanup_test (
    id INTEGER,
    data VARCHAR,
    PAC_KEY (id),
    PROTECTED (data)
);

statement ok
CREATE TABLE cleanup_link_test (
    id INTEGER,
    cleanup_id INTEGER,
    PAC_LINK (cleanup_id) REFERENCES cleanup_test(id)
);

# Drop the referenced table
statement ok
DROP TABLE cleanup_test;

# The link from cleanup_link_test should be automatically removed
# Verify by saving and reloading metadata
statement ok
PRAGMA save_pac_metadata('__TEST_DIR__/pac_drop_test.json');

statement ok
PRAGMA clear_pac_metadata;

statement ok
PRAGMA load_pac_metadata('__TEST_DIR__/pac_drop_test.json');

# cleanup_link_test should still exist but without the link to cleanup_test
# We can't directly verify this in SQL, but the metadata should be cleaned up

# Test 47: DROP TABLE IF EXISTS with PAC metadata
statement ok
CREATE PU TABLE if_exists_test (
    id INTEGER,
    name VARCHAR,
    PAC_KEY (id),
    PROTECTED (name)
);

statement ok
DROP TABLE IF EXISTS if_exists_test;

# Verify metadata was cleaned up by trying to drop non-existent table
statement ok
DROP TABLE IF EXISTS if_exists_test;

# Test 48: Multiple DROP operations
statement ok
CREATE PU TABLE multi_drop_test (
    id INTEGER,
    col1 VARCHAR,
    col2 VARCHAR,
    col3 VARCHAR,
    ref1 INTEGER,
    ref2 INTEGER,
    PAC_KEY (id)
);

statement ok
CREATE TABLE multi_ref1 (id INTEGER);

statement ok
CREATE TABLE multi_ref2 (id INTEGER);

statement ok
ALTER PU TABLE multi_drop_test ADD PROTECTED (col1, col2, col3);

statement ok
ALTER PU TABLE multi_drop_test ADD PAC_LINK (ref1) REFERENCES multi_ref1(id);

statement ok
ALTER PU TABLE multi_drop_test ADD PAC_LINK (ref2) REFERENCES multi_ref2(id);

# Drop protected columns one by one
statement ok
ALTER PU TABLE multi_drop_test DROP PROTECTED (col1);

statement ok
ALTER PU TABLE multi_drop_test DROP PROTECTED (col2);

statement ok
ALTER PU TABLE multi_drop_test DROP PROTECTED (col3);

# Drop links one by one
statement ok
ALTER PU TABLE multi_drop_test DROP PAC_LINK (ref1);

statement ok
ALTER PU TABLE multi_drop_test DROP PAC_LINK (ref2);

# Now the table should have no PAC metadata except possibly PAC_KEY
# Try to drop again should fail
statement error
ALTER PU TABLE multi_drop_test DROP PROTECTED (col1);
----
Column 'col1' is not marked as protected

statement error
ALTER PU TABLE multi_drop_test DROP PAC_LINK (ref1);
----
No PAC LINK found on column 'ref1'

# Cleanup DROP tests
statement ok
DROP TABLE IF EXISTS drop_test;

statement ok
DROP TABLE IF EXISTS drop_ref_table;

statement ok
DROP TABLE IF EXISTS comp_drop_test;

statement ok
DROP TABLE IF EXISTS comp_drop_ref;

statement ok
DROP TABLE IF EXISTS no_pac_table;

statement ok
DROP TABLE IF EXISTS cleanup_link_test;

statement ok
DROP TABLE IF EXISTS multi_drop_test;

statement ok
DROP TABLE IF EXISTS multi_ref1;

statement ok
DROP TABLE IF EXISTS multi_ref2;

statement ok
PRAGMA clear_pac_metadata;

# ============================================================================
# ALTER TABLE SET PU / UNSET PU Tests
# ============================================================================

# Test 49: ALTER TABLE SET PU on a regular table
statement ok
CREATE TABLE set_pu_test (
    id INTEGER PRIMARY KEY,
    name VARCHAR,
    value INTEGER
);

statement ok
INSERT INTO set_pu_test VALUES (1, 'Alice', 100), (2, 'Bob', 200);

# Before SET PU - can project columns
query III
SELECT * FROM set_pu_test ORDER BY id;
----
1	Alice	100
2	Bob	200

# Mark as privacy unit
statement ok
ALTER TABLE set_pu_test SET PU;

# After SET PU - cannot project columns (it's now a privacy unit, PK is protected)
statement error
SELECT * FROM set_pu_test;
----
PAC rewrite: protected column 'set_pu_test.id' can only be accessed inside aggregate functions

# Aggregation should work
query I
SELECT SUM(value) FROM set_pu_test;
----
600

# Test 50: ALTER TABLE UNSET PU removes privacy unit status
statement ok
ALTER TABLE set_pu_test UNSET PU;

# After UNSET PU - can project columns again
query III
SELECT * FROM set_pu_test ORDER BY id;
----
1	Alice	100
2	Bob	200

# Test 51: SET PU on table that already has PAC metadata (PROTECTED columns)
statement ok
CREATE TABLE set_pu_with_protected (
    id INTEGER,
    public_col VARCHAR,
    secret_col INTEGER,
    PROTECTED (secret_col)
);

statement ok
INSERT INTO set_pu_with_protected VALUES (1, 'public1', 111), (2, 'public2', 222);

# Table has PROTECTED but is not a privacy unit - can project non-protected columns
query II
SELECT id, public_col FROM set_pu_with_protected ORDER BY id;
----
1	public1
2	public2

# Cannot project protected columns
statement error
SELECT secret_col FROM set_pu_with_protected;
----
PAC rewrite: protected column 'set_pu_with_protected.secret_col' can only be accessed inside aggregate functions

# Now SET PU to make it a privacy unit
statement ok
ALTER TABLE set_pu_with_protected SET PU;

# After SET PU with PROTECTED columns defined:
# - Non-protected columns CAN still be projected
# - Only protected columns are restricted
query II
SELECT id, public_col FROM set_pu_with_protected ORDER BY id;
----
1	public1
2	public2

# Protected columns still cannot be projected
statement error
SELECT secret_col FROM set_pu_with_protected;
----
PAC rewrite: protected column 'set_pu_with_protected.secret_col' can only be accessed inside aggregate functions

# Test 52: UNSET PU on table with PROTECTED columns - keeps PROTECTED status
statement ok
ALTER TABLE set_pu_with_protected UNSET PU;

# After UNSET PU - can still project non-protected columns
query II
SELECT id, public_col FROM set_pu_with_protected ORDER BY id;
----
1	public1
2	public2

# But still cannot project protected columns
statement error
SELECT secret_col FROM set_pu_with_protected;
----
PAC rewrite: protected column 'set_pu_with_protected.secret_col' can only be accessed inside aggregate functions

# Test 53: SET PU is idempotent (calling twice is OK)
statement ok
ALTER TABLE set_pu_test SET PU;

statement ok
ALTER TABLE set_pu_test SET PU;

# Test 54: UNSET PU is idempotent (calling twice is OK)
statement ok
ALTER TABLE set_pu_test UNSET PU;

statement ok
ALTER TABLE set_pu_test UNSET PU;

# Test 55: Case insensitivity in SET PU / UNSET PU
statement ok
ALTER TABLE SET_PU_TEST set pu;

statement ok
alter table set_pu_test UNSET PU;

# Cleanup SET PU / UNSET PU tests
statement ok
DROP TABLE IF EXISTS set_pu_test;

statement ok
DROP TABLE IF EXISTS set_pu_with_protected;

statement ok
PRAGMA clear_pac_metadata;

# ============================================================================
# Cycle Detection Tests: PU tables cannot link to other PU tables
# ============================================================================

# Test 56: Setup - Create a PU table (privacy unit)
statement ok
CREATE PU TABLE pu_users (
    id INTEGER,
    name VARCHAR,
    PAC_KEY (id),
    PROTECTED (name)
);

# Test 57: CREATE PU TABLE with PAC_LINK to another PU table should fail
statement error
CREATE PU TABLE pu_orders (
    id INTEGER,
    user_id INTEGER,
    amount INTEGER,
    PAC_KEY (id),
    PAC_LINK (user_id) REFERENCES pu_users(id)
);
----
Cannot create PAC LINK from PAC table 'pu_orders' to PAC table 'pu_users'. PAC tables cannot link to other PAC tables (cycles not supported).

# Test 58: Regular table can link to PU table - this should work
statement ok
CREATE TABLE regular_orders (
    id INTEGER,
    user_id INTEGER,
    amount INTEGER
);

statement ok
ALTER PU TABLE regular_orders ADD PAC_LINK (user_id) REFERENCES pu_users(id);

# Test 59: ALTER PU TABLE ADD PAC_LINK from PU table to PU table should fail
statement ok
CREATE PU TABLE pu_products (
    id INTEGER,
    name VARCHAR,
    PAC_KEY (id)
);

statement error
ALTER PU TABLE pu_products ADD PAC_LINK (id) REFERENCES pu_users(id);
----
Cannot create PAC LINK from PAC table 'pu_products' to PAC table 'pu_users'. PAC tables cannot link to other PAC tables (cycles not supported).

# Test 60: ALTER TABLE SET PU should fail if table already has links to PU tables
statement ok
CREATE TABLE will_become_pu (
    id INTEGER,
    user_id INTEGER,
    data VARCHAR
);

# First add a link to the PU table
statement ok
ALTER PU TABLE will_become_pu ADD PAC_LINK (user_id) REFERENCES pu_users(id);

# Now trying to SET PU should fail because it would create a PU->PU link
statement error
ALTER TABLE will_become_pu SET PU;
----
Cannot create PAC LINK from PAC table 'will_become_pu' to PAC table 'pu_users'. PAC tables cannot link to other PAC tables (cycles not supported).

# Test 61: Regular table with link to non-PU table can become PU
statement ok
CREATE TABLE target_non_pu (
    id INTEGER,
    value VARCHAR
);

statement ok
CREATE TABLE source_table (
    id INTEGER,
    target_id INTEGER,
    data VARCHAR
);

statement ok
ALTER PU TABLE source_table ADD PAC_LINK (target_id) REFERENCES target_non_pu(id);

# This should succeed because target_non_pu is not a PU table
statement ok
ALTER TABLE source_table SET PU;

# Test 62: Chain validation - indirect cycles should also be prevented
# If A is PU and B links to A, then B cannot become PU
# (This is the same as Test 60 but verifies the concept)

# Test 63: Multiple links - only links to PU tables should be rejected
statement ok
CREATE TABLE multi_link_test (
    id INTEGER,
    pu_ref INTEGER,
    non_pu_ref INTEGER
);

# Link to non-PU table should work
statement ok
ALTER PU TABLE multi_link_test ADD PAC_LINK (non_pu_ref) REFERENCES target_non_pu(id);

# Link to PU table should also work (table is not a PU table yet)
statement ok
ALTER PU TABLE multi_link_test ADD PAC_LINK (pu_ref) REFERENCES pu_users(id);

# But now SET PU should fail because of the link to pu_users
statement error
ALTER TABLE multi_link_test SET PU;
----
Cannot create PAC LINK from PAC table 'multi_link_test' to PAC table 'pu_users'. PAC tables cannot link to other PAC tables (cycles not supported).

# Test 64: After removing PU status from target, link should be allowed

